//
// Generated by Bluespec Compiler, version 2025.01 (build a798d8a9)
//
// On Wed Mar 19 19:21:56 PDT 2025
//
//
// Ports:
// Name                         I/O  size props
// ARADDR                         O    32 const
// ARPROT                         O     3 const
// ARVALID                        O     1 const
// RREADY                         O     1 const
// AWADDR                         O    32 reg
// AWPROT                         O     3 const
// AWVALID                        O     1
// WDATA                          O    32 const
// WSTRB                          O     4 const
// WVALID                         O     1
// BREADY                         O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// ARREADY                        I     1 unused
// RDATA                          I    32 unused
// RRESP                          I     2 unused
// RVALID                         I     1 unused
// AWREADY                        I     1 reg
// WREADY                         I     1 reg
// BRESP                          I     2 unused
// BVALID                         I     1 reg
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module nm(CLK,
	  RST_N,

	  ARADDR,

	  ARPROT,

	  ARVALID,

	  ARREADY,

	  RREADY,

	  RDATA,

	  RRESP,

	  RVALID,

	  AWADDR,

	  AWPROT,

	  AWVALID,

	  AWREADY,

	  WDATA,

	  WSTRB,

	  WVALID,

	  WREADY,

	  BREADY,

	  BRESP,

	  BVALID);
  input  CLK;
  input  RST_N;

  // value method read_arADDR
  output [31 : 0] ARADDR;

  // value method read_arPROT
  output [2 : 0] ARPROT;

  // value method read_arVALID
  output ARVALID;

  // action method read_arREADY
  input  ARREADY;

  // value method read_rREADY
  output RREADY;

  // action method read_rDATA
  input  [31 : 0] RDATA;

  // action method read_rRESP
  input  [1 : 0] RRESP;

  // action method read_rVALID
  input  RVALID;

  // value method write_awADDR
  output [31 : 0] AWADDR;

  // value method write_awPROT
  output [2 : 0] AWPROT;

  // value method write_awVALID
  output AWVALID;

  // action method write_awREADY
  input  AWREADY;

  // value method write_wDATA
  output [31 : 0] WDATA;

  // value method write_wSTRB
  output [3 : 0] WSTRB;

  // value method write_wVALID
  output WVALID;

  // action method write_wREADY
  input  WREADY;

  // value method write_bREADY
  output BREADY;

  // action method write_bRESP
  input  [1 : 0] BRESP;

  // action method write_bVALID
  input  BVALID;

  // signals for module outputs
  wire [31 : 0] ARADDR, AWADDR, WDATA;
  wire [3 : 0] WSTRB;
  wire [2 : 0] ARPROT, AWPROT;
  wire ARVALID, AWVALID, BREADY, RREADY, WVALID;

  // register addr
  reg [31 : 0] addr;
  wire [31 : 0] addr$D_IN;
  wire addr$EN;

  // register awready
  reg awready;
  wire awready$D_IN, awready$EN;

  // register bvalid
  reg bvalid;
  wire bvalid$D_IN, bvalid$EN;

  // register state
  reg state;
  wire state$D_IN, state$EN;

  // register wready
  reg wready;
  wire wready$D_IN, wready$EN;

  // value method read_arADDR
  assign ARADDR = 32'd0 ;

  // value method read_arPROT
  assign ARPROT = 3'd0 ;

  // value method read_arVALID
  assign ARVALID = 1'd1 ;

  // value method read_rREADY
  assign RREADY = 1'd1 ;

  // value method write_awADDR
  assign AWADDR = addr ;

  // value method write_awPROT
  assign AWPROT = 3'd0 ;

  // value method write_awVALID
  assign AWVALID = !state || !awready ;

  // value method write_wDATA
  assign WDATA = 32'hDEADBEEF ;

  // value method write_wSTRB
  assign WSTRB = 4'b1111 ;

  // value method write_wVALID
  assign WVALID = !state || !wready ;

  // value method write_bREADY
  assign BREADY = state && !bvalid ;

  // register addr
  assign addr$D_IN = (addr != 32'h0) ? 32'h0 : 32'hC0000000 ;
  assign addr$EN = 1'b1 ;

  // register awready
  assign awready$D_IN = AWREADY ;
  assign awready$EN = 1'd1 ;

  // register bvalid
  assign bvalid$D_IN = BVALID ;
  assign bvalid$EN = 1'd1 ;

  // register state
  assign state$D_IN = 1'd1 ;
  assign state$EN = !state || awready && wready && bvalid ;

  // register wready
  assign wready$D_IN = WREADY ;
  assign wready$EN = 1'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        addr <= `BSV_ASSIGNMENT_DELAY 32'h0;
	awready <= `BSV_ASSIGNMENT_DELAY 1'd0;
	bvalid <= `BSV_ASSIGNMENT_DELAY 1'd0;
	state <= `BSV_ASSIGNMENT_DELAY 1'd0;
	wready <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (addr$EN) addr <= `BSV_ASSIGNMENT_DELAY addr$D_IN;
	if (awready$EN) awready <= `BSV_ASSIGNMENT_DELAY awready$D_IN;
	if (bvalid$EN) bvalid <= `BSV_ASSIGNMENT_DELAY bvalid$D_IN;
	if (state$EN) state <= `BSV_ASSIGNMENT_DELAY state$D_IN;
	if (wready$EN) wready <= `BSV_ASSIGNMENT_DELAY wready$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    addr = 32'hAAAAAAAA;
    awready = 1'h0;
    bvalid = 1'h0;
    state = 1'h0;
    wready = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // nm

